                                METERMAN 2 NOTES

== TextBundle Changes ==

There will be only one game TextBundle, installed via Meterman.setGameBundle(). With this in place, game objects will store only bundle passage names, which will be sent back to the system via BundleSource objects (see below). This makes loading objects easier, and also allows changing object text even after they've been loaded. Instances of TextBundle no longer need to be passed around to anyone who needs them. The game bundle can chain to another bundle, to make organizing game text among multiple files possible.

== Scripting ==

I'm going to do some heavy revisions of the Meterman engine in preparation for writing Riverboat: I realized that to implement suitably interactive object behavior would require a lot of tortuous coupling of game logic in Java classes to multiple passages in a TextBundle, just to effect variable text for, say, a room description.

And so, I need an intuitive way to put simple logic into the text itself. There are a few main ways one can approach doing this:

1. Inline control directives

  This style is like Inform 7's "Text with variations" substitutions [I7-Text], where delimited control directives are intermixed into the text, and determine which portions are included based on a conditional expression over state variables.
  
  To implement this in Meterman I'd perform simple parsing to find the conditional blocks, and then evaluate the conditions themselves using either BeanShell or a simple expression language like Apache JEXL [JEXL].

2. Scripts that return text

  This is the style of Inform 6 in that if a property is a routine (as opposed to a plain string), then all the text that it emits is concatenated into the return value of the routine.
  
  I'd implement this using BeanShell, with special routines with short names--perhaps emit() or out(), and passage()--that would add literal text or bundle passages to the string return value.

3. JSP Style

  In this style, passages are converted to scripts before being evaluated to yield a string. Segments of plain text are converted to emit() calls, and you can embed little "scriptlets" directly in the text to perform whatever logic you'd like.

I think I'm going to go with the JSP style, and actually borrow its syntax for scriplets and expressions.

  <%  %>  demarcates a scriptlet that will be included in the generated BeanShell script verbatim, and can be used to set variables, perform branching, etc.

  <%= %>  demarcates an expression whose resulting value will be converted to a string and emitted inline.

Anything outside of these delimiters is treated as plain text, and will be converted to calls to emit().

== TextSource ==

Nearly all instances of String in the current API should be replaced with a TextSource interface that can return a string. Its implementations:

  StringSource
    Constructed with a String parameter, and simply passes back that string.
    
  BundleSource
    Keeps a bundle passage name as state, and returns the respective passage text.

== Automatically Imported/Bound Objects ==

Regardless of which style of TextBundle scripting we end up choosing, there will be certain objects available in the namespace:

  gm
        instance of GameManager

  ui
        instance of the MetermanUI

  sound
        instance of the SoundManager

  player
        the Player object

  worldData
        the worldState's worldData map

  selectedEntity
        currently selected Entity, or null if none. During the processing of entity actions, this will necessarily be set.

  currentRoom
        current Room

  <state>
        a "game global" state object set on the bundle itself. The name of the state object--and potentially multiple state objects--can be set via bundle methods.

Furthermore, there will be a variant of TextBundle.getPassage() that lets the caller add bindings to the scripting namespace for that particular call.

== Battle Mechanics ==

Borrowing the idea from Undertale of a single battle mechanic to represent challenges, I thought of having a "typing shooter" system where multicolored words would descend and you need to type them to shoot them from the air before they reach the bottom. With variable speeds and difficulties, this could be fun.

For certain battles, the appearance of letters could be synchronized to music that will play for that battle.

== RPG'ification ==

(power-ups for typing game; levels of difficulty based on WPM)


                                == References ==

[I7-Text]   http://inform7.com/learn/man/WI_5_6.html
[JEXL]      http://commons.apache.org/jexl/

# --------------------------------------------------------------------------- #
# :autoIndent=simple:maxLineLen=84:mode=text:noTabs=true:tabSize=4:wrap=soft: #
# :indentSize=2:                                                              #
# --------------------------------------------------------------------------- #
