            Meterman Design Notes
            ---------------------

Some big picture code notes:

- References (say, room to room exits, or the location of items) will be stored as unique
  string identifiers (ex. "turnip-room") rather than actual Java object references. There
  will be a mapper class that will return the Java Room or Entity that corresponds to a
  given ID. This avoids having a tangled object graph, which makes it easier to
  instantiate and serialize the game world.
  
  The ID corresponds to a Java class, rather than to any name displayed to the user, so
  two Entity instances could have different names while sharing the same class.
  
  In the event that the ID isn't found as a map key, then a default error object will be
  returned, that has a description like "A misty void gapes where you expected to find the
  <missing ID>, revealing an error in the world's programmers."

- There will be one big GameState object that contains the whole game world graph. This
  will be serialized and deserialized (using kryo) to implement save/restore (and possibly
  even undo) functionality. Given that kryo can round-trip 1000000+ objects in a second,
  and my game world will have less than 1000 objects, using it for undo should be feasible.

- Upon starting a new game, the entire game world will be instantiated. Rooms and entities
  will be constructed, all of their init() methods called, and entities will be placed in
  rooms based on the room ID given in a configuration file.

- Every Room and Entity will have a no-arg constructor that doesn't actually initialize
  the game state, so that they can be deserialized properly. Initial game state will be
  set in the init() method.

- The UI will be in a separate package, abstracted from the Swing/AWT API, so that I can
  switch to a different UI--like libGDX or GWT--in the future.

And now world model notes:

- Rooms and Entities and the Player will be distinct types. There are no containers or
  supporters or vehicles as special attributes -- enough hook methods will be provided
  so that, say, a car entity can twiddle with the game world enough to follow the player
  around and make it look like he's in a car. Doors will be handled by the Room, if
  a key or such is needed to open one.

- The GameState object will have a String->String map so that objects can communicate
  state to one another without directly reaching into other objects.

- We'll have a series of Listener interfaces (PlayerMovingListener,
  ObjectSelectedListener, etc.) that objects can implement to register themselves to
  receive events when the corresponding game world events occur. A special
  BeforeActionListener can be registered to be notified before an action is passed
  to the selected object, and potentially interrupt the action. The parallel is
  AfterActionListener, which is called after the object processes the action.

  Basically, all the Inform6 properties like "react_before", "after", "daemon" etc.
  will be handled by objects registering themselves as listeners with the GameManager.

- An Entity will have a getDisplayName() method that will return a String representing
  how it should be dhown in the UI. This can include modifiers like "(worn)" or
  "(equipped)", which the Entity will determine by querying the Player object. The
  Entity itself maintains no state about being worn, equipped, or such.

- Rooms have a getExitName() method that returns a short version of the room name to
  be shown in the exit button area in the UI.
  
- To allow multiple games to exist in one codebase, the configuration file will specify
  the game name -- then a special initialization routine will map the game name to a
  game class and transfer control to it. So we can have multiple games without introducing
  too much abstraction.

What I'll do here is read through the attributes and properties appendices in the DM4
and make a list of the functionality I'd like to support in my world model (and how
it applies to the GameManager, and Room and Entity interfaces):

--Entity--

concealed: present in a room but not displayed in the entity list

takeable: the player can take it

getActions: returns a list of string actions to show in the UI

action: responds to an action button pressed in the UI

display name: short name to display in lists

description: full text to display in the selected entity text area

enterScope: called when the entity enters scope (i.e. when it comes to be in the same
            room as the player).

exitScope: called when the entity exits scope

--Room--

visited: the player has visited the room (and thus its name can be displayed in the exit
         list of adjacent rooms.

exits: a map from direction_constant -> room ID (or null)



------------------------------------------------------------
:maxLineLen=90:noTabs=true:
